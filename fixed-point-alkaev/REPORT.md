| Лабораторная работа №1 | 22Б05|  Архитектура компьютера |
| ---------------------- | ----------- | ---- |
| Представление чисел    |Алькаев Равиль Юрисович      | 2023 (ППА2) |

## Инструментарий
> Программа написана на C++ (11.4.0). Выполнено в среде разработки VS Code.

## Что реализовано
> Написал программу, которая позволяет выполнять арифметические действия с дробными числами в формате фиксированная точка. Программа использует только целочисленные вычисления и типы данных.

## Константы

> Для работы программы нам нужны будут константы, они инициализированы в файле constant.h
> - chars16_to_2 - словарь, который нужен для перевода из 16-ричной системы счисления в массив из 4 битов
> - Rounding_* - типы округлений

## Функции 
> Для работы программы нам понадобятся некоторые вспомогательные функции (Все они реализованы в help_function.cpp)
> - is_valid() - проверка на правильность входной строки (является ли она кодом числа в 16-ричной записи)
> - hex_to_binary_code() - функция для перевода из 16-ричной в 2-ичную систему
> - int_to_code() функция, которая из integer получает code
> - has_not_0() - проверка на неравество 0)
> - increase() и decrease() увеличение или уменьшение числа на 1 соотвественно (зависит от округления)
> - floor_div() деление с округление в сторону минус бесконечности

## класс FixedPoint

> Все наши числа хранятся в классе FixedPoint, и все операции выполнены (+,-,*,/) над классом
```
class FixedPoint {
public:
    int a; 
    int b;
    std::vector<int> code;
    int rounding;
    long long integer;
 }
 ```
 ## что за что отвечает
> - Где поля a и b показывают количество бит перед и после точки соотвественно
> - code бинарный код нашего числа реализованный как дополнение до двух
> - rounding - тип округления (Rounding_TOWARD_ZERO = 0, Rounding_NEAREST_EVEN = 1, Rounding_TOWARD_INFINITY = 2,Rounding_TOWARD_NEG_INFINITY = 3)
> - integer - целое числи полученное преобразованием к десятичной записи code, полученное число будет в $2^b$ раз больше данного

## Операции над классом

###  Сложение и вычитание
>  Реализованно как сложение(вычитание) значений полей integer, а потом преобразованием в code (с помощью функции int_to_code), стоит заметить, что у нас модулярная арифметика, а значит если наше значение num1.integer +/- num2.integer >= $2^{a+b-1}$ просто вычитаем $2^{a+b-1}$, а если наоброт получили меньше чем -$2^{a+b-1}$, то здесь уже надо прибавить $2^{a+b-1}$

### Умножение,
>  Как и в случае сложения и вычитания мы вначале вычисляем num1.integer * num2.integer, но теперь нам следует поделить произведение на $2^b$ и окргулить результат ссылаясь на num1.rounding (num2.rounding ему равен) 
> - пусть у нас есть два числа num1.integer * $2^{-b}$ и num2.integer * $2^{-b}$, в результате мы получим num1.integer * num2.integer * $2^{-2b}$, перемножим сначала num1.integer * num2.integer, а потом уже отбросим b битов исходя из округления
> - num1.rounding == Rounding_TOWARD_ZERO Здесь все просто, сдвиг на b битов вправо 
> - num1.rounding == Rounding_NEAREST_EVEN Рассмотрим последние b битов числа. Если эти биты образуют значение большее, чем $2^{b-1}$, то при их отбрасывании к оставшемуся числу следует прибавить 1, что соответствует округлению вверх (к ближайшему четному, если ближайшее четное больше текущего числа). Если последние b битов образуют ровно $2^{b-1}$, то, отбрасывая их, мы обращаем внимание на последний бит оставшегося числа: если он равен 0, то оставляем число как есть, а если 1 — добавляем к числу 1,(ближайшего нет, округляем к четному). Во всех других случаях просто отбрасываем $2^{b-1}$ битов без изменений.
> - num1.rounding == Rounding_TOWARD_INFINITY просто умножим число на -1 и воспользуемся функцией floor_div(), и отбрасываем не нужные биты
> - num1.rounding == Rounding_TOWARD_NEG_INFINITY просто floor_div()
>> После этих манипуляций остается лишь отбросить b правых битов, и взять a+b младших битов


### Деление
> - Для начала разберем частные случаи, когда числитель или знаменатель равен нулю
> - В противоположном случае num1.integer * $2^{b}$ делится на num2.integer, числитель домножили на $2^{b}$ для получения битиков после точки, а дальше нужно округлить и перевести в нужный формат
> - Также мы будем помнить знак результата, чтобы можно было просто работать с модулями чисел, в округление к 0 и к бесконечностям нам поможет функция floor_div(). В округлении к ближайшему чётному – просто дополнительно обращаем внимание на остаток от деления num1.integer * $2^{b}$ на num2.integer. В случае если он больше половины num2.integer или равен ей и частное нечётно, то частное увеличиваем на 1. В конце если частное вышло за диапазон, нужно его вернуть в него (модулярная арифметика). Следовательно ответ — частное, умноженное на $2^{b}$.


### Вывод чисел
> Для начала определим целые переменные 
> - first_part — это ближайшее целое число к нашему числу x ,которое находится между x и 0 (округлённое вверх число x (если оно отрицательное), иначе просто целая часть числа).
> - second_part — целое число, которое образуют цифры десятичной записи после запятой.
> - first_nulls — количество нулей после запятой до начала second_part.
> - В переменной rounded_second_part будем хранить первые три цифры записи числа после запятой. Мы хотим выводить числа в формате {целая часть}.{rounded_second_part}, но rounded_second_part в некоторых случаях приходится увеличивать/уменьшать на 1 в зависимости от правила округления цифр, которые идут дальше после первых 3 после запятой.

## main.cpp
> В главном файле, имеется функция solve(), которая занимается парсингом и выбором нужной операции, а также есть функция splitString(), которая считывает строку и преобразует ее в массив

## Результаты на тестовых данных

| Ввод | Вывод |
|------|-------|
|16.12 0 0x17360|23.210|
|8.8 1 0xdc9f + 0xd736|-76.168|
|8.8 2 0xdc9f + 0xd736|-76.167|
|4.4 3 0x12 / 0x100| div_by_0|
|4.4 3 0x100 / 0x12| 0.000|
|4.4 0 0x12| 1.125|
|4.4 0 0x12 - 0x100|1.125|
|16.12 0 0x17360 / 0xa1ffff|0.008|
|16.12 0 0x7fff360 / 0x8a1ffff|-1.085|
|8.8 1 0xdc9f - 0xd736|5.410|
|8.8 2 0xdc9f - 0xd736|5.411|
|4.4 3 0x12 * 0x100|0.000|
|8.8 3 0xa2 * 0x71|0.277|
|8.8 2 0xa2 * 0x71|0.282|
